<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Carnet de découvertes</title><link>https://fljd.in/categories/linux/</link><description>Recent content in Linux on Carnet de découvertes</description><generator>Hugo -- gohugo.io</generator><language>fr</language><managingEditor>Florent Jardin</managingEditor><lastBuildDate>Mon, 14 Oct 2024 10:30:00 +0200</lastBuildDate><atom:link href="https://fljd.in/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Poissons et coquillages</title><link>https://fljd.in/2024/10/14/poissons-et-coquillages/</link><pubDate>Mon, 14 Oct 2024 10:30:00 +0200</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2024/10/14/poissons-et-coquillages/</guid><description>&lt;p>En tant que pur produit académique des années 2010, mon langage de script de prédilection a
toujours été le Bash (&lt;em>Bourne Again Shell&lt;/em>). Non sans ignorer qu&amp;rsquo;il ait pu en exister d&amp;rsquo;autres, je
ne me suis jamais vraiment tourné vers d&amp;rsquo;autres shells pour automatiser les tâches du quotidien
dans mon métier de DBA.&lt;/p>
&lt;p>Et pour cause, j&amp;rsquo;ai administré des centaines de serveurs de distributions très variées et il
n&amp;rsquo;était pas bien vu d&amp;rsquo;installer des dépendances systèmes lourdes pour enrichir des scripts Python
ou Perl. Nous apprenions donc à écrire des scripts portables et universels, compatibles partout
où nous déposions nos valises.&lt;/p>
&lt;p>Me suis-je enfermé dans un dogme conservateur, en m&amp;rsquo;interdisant &lt;em>de facto&lt;/em> à me tourner vers des
shells modernes et bien plus aisés à appréhender ?&lt;/p></description></item><item><title>Construire PostgreSQL avec Meson</title><link>https://fljd.in/2022/09/29/construire-postgresql-avec-meson/</link><pubDate>Thu, 29 Sep 2022 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2022/09/29/construire-postgresql-avec-meson/</guid><description>&lt;p>Alors que la version 15 de PostgreSQL se prépare à sortir dans les &lt;a href="https://www.postgresql.org/about/news/postgresql-15-rc-1-released-2516/" target="_blank" rel="noopener">prochains
jours&lt;/a>, le groupe de développement du projet communautaire ont intégré &lt;a href="https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=e6927270cd18d535b77cbe79c55c6584351524be" target="_blank" rel="noopener">leurs
récents travaux&lt;/a> pour accélérer les tâches d&amp;rsquo;automatisation et de compilation
à l&amp;rsquo;aide du système de construction &lt;a href="https://mesonbuild.com/" target="_blank" rel="noopener">Meson&lt;/a>.&lt;/p>
&lt;p>Ce chantier n&amp;rsquo;est pas anodin et redessine les contours de l&amp;rsquo;écosystème du moteur
de bases de données open-source le plus avancé au monde. Depuis sa forme libre
publiée en 1998, PostgreSQL repose sur des solutions robustes et éprouvées, mais
de plus en plus complexes à maintenir pour les nouvelles générations de
contributeur·rices. En proposant de se tourner vers un logiciel comme Meson, ces
amoureux et amoureuses du libre se tournent résolument vers l&amp;rsquo;avenir.&lt;/p></description></item><item><title>BorgBackup ou la sauvegarde facile</title><link>https://fljd.in/2021/08/24/borg-ou-la-sauvegarde-facile/</link><pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2021/08/24/borg-ou-la-sauvegarde-facile/</guid><description>&lt;p>Jusqu&amp;rsquo;à très récemment, je ne me préoccupais pas de la pertinence de mes
sauvegardes de fichiers personnels réalisées naïvement avec un script &lt;code>rsync&lt;/code>.
C&amp;rsquo;est honteux dans nos métiers, mais l&amp;rsquo;adage du cordonnier s&amp;rsquo;est vérifié avec
moi lors de l&amp;rsquo;exécution d&amp;rsquo;un vulgaire &lt;code>find $NOVAR/ -delete&lt;/code> durant des tests.&lt;/p>
&lt;p>Après cet épisode et l&amp;rsquo;amertume d&amp;rsquo;avoir perdu quelques travaux, ou la surprise
de découvrir les ravages de leur disparition plusieurs semaines après ma fatale
erreur, je me suis tourné vers l&amp;rsquo;outil incontournable dont tous mes collègues me
parlaient : &lt;a href="https://borgbackup.readthedocs.io/en/stable/" target="_blank" rel="noopener">BorgBackup&lt;/a>&lt;/p></description></item><item><title>Les liens physiques avec pg_upgrade</title><link>https://fljd.in/2020/04/23/les-liens-physiques-avec-pgupgrade/</link><pubDate>Thu, 23 Apr 2020 15:30:00 +0200</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2020/04/23/les-liens-physiques-avec-pgupgrade/</guid><description>&lt;p>La création d&amp;rsquo;un lien sous Unix se réalise avec les commandes &lt;a href="https://www.gnu.org/software/coreutils/ln" target="_blank" rel="noopener">ln&lt;/a> ou
&lt;a href="https://www.gnu.org/software/coreutils/cp" target="_blank" rel="noopener">cp&lt;/a>. Cette action permet de &lt;em>lier&lt;/em> deux fichiers vers la même donnée et
de rendre disponible une ressource par l&amp;rsquo;intermédiaire de l&amp;rsquo;un ou de l&amp;rsquo;autre de
ces fichiers.&lt;/p>
&lt;p>Cependant, les opérations diffèrent selon le type de ce lien. Le plus connu reste
le &lt;em>symlink&lt;/em>, le lien symbolique. Mais qu&amp;rsquo;en est-il des autres ? Comment se
caractérisent-ils et dans quels contextes ? En vrai, qu&amp;rsquo;est-ce qu&amp;rsquo;un &lt;em>inode&lt;/em> ?
Et PostgreSQL dans tout ça ? Autant de petites questions de curiosité que
j&amp;rsquo;aborde avec vous dans cet article !&lt;/p></description></item><item><title>Gestion des signaux internes</title><link>https://fljd.in/2020/01/17/gestion-des-signaux-internes/</link><pubDate>Fri, 17 Jan 2020 20:00:00 +0200</pubDate><author>Florent Jardin</author><guid>https://fljd.in/2020/01/17/gestion-des-signaux-internes/</guid><description>&lt;p>Je voulais m&amp;rsquo;attarder sur une notion que je n&amp;rsquo;avais pas exploré à l&amp;rsquo;époque où
j&amp;rsquo;apprenais à naviguer dans un terminal GNU/Linux sur les sièges de l&amp;rsquo;école et
où l&amp;rsquo;on usait de commandes apprises par cœur : les signaux !&lt;/p>
&lt;p>Les signaux les plus connus et les plus utilisés sont les numéros 6 &lt;code>SIGABRT&lt;/code> et
9 &lt;code>SIGKILL&lt;/code>, ça vous revient ? Pourquoi en existe-t-il autant, dans quels
contextes sont-ils nécessaires et de quelles façons les configure-t-on ? Prenons
le temps de (re)découvrir les signaux UNIX et leurs utilisations dans PostgreSQL !&lt;/p></description></item></channel></rss>